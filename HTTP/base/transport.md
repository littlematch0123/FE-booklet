# 前端学HTTP之数据传输

&emsp;&emsp;上一篇中，介绍了[网络基础](http://www.cnblogs.com/xiaohuochai/p/6140123.html)。本文将详细介绍客户机在浏览网页abc.com时，数据在网络中的传输过程

![transport1](https://pic.xiaohuochai.site/blog/HTTP_transport1.jpg)

&emsp;&emsp;以图为例，PC1通过HTTP协议访问位于Server上的网页。那么，网页数据在网络中是如何传输的呢？下面是具体的实现步骤

&nbsp;

### 客户机处理

&emsp;&emsp;HTTP协议的职责是生成针对目标WEB服务器的HTTP请求报文，该报文就是需要传递的数据

&emsp;&emsp;下沉到传输层后，由于HTTP协议使用的是TCP协议，为了方便通信，将HTTP请求报文按序号分为多个报文段(segment)，并对每个报文段进行封装。PC1使用本地一个大于1024以上的随机TCP源端口(这里假设是1030)建立到目的服务器TCP80号端口(HTTPS协议对应的端口号是443)的连接，TCP源端口和目的端口被加入到报文段中，学名叫协议数据单元(Protocol Data Unit, PDU)。因TCP是一个可靠的传输控制协议，传输层还会加入序列号、窗口大小等参数

&emsp;&emsp;传输层封装后的数据分段下沉到网络层后，封装网络层的头部，主要就是添加源和目的IP地址，成为数据包。用户通常使用主机名或域名来访问服务器，这时就需要通过应用层的DNS服务来通过域名查找IP地址，或逆向从IP地址反查域名。这里的源IP地址是193.1.1.2，目的IP地址是195.1.1.2

&emsp;&emsp;网络层封装后的数据包下沉到数据链路层，封装帧头和帧尾。帧尾是添加被称做CRC的循环冗余校验部分。帧头主要是添加数据链路层的地址，即数据链路层的源地址和目的地址，用在以太网上的体现就是添加源MAC地址和目的MAC地址。PC1比较要去往的目标IP地址，发现服务器的IP地址195.1.1.2不在本地网络中，PC1知道要发往不同网络中的数据包，首先要发往网关，也就是图中路由器R1快速以太网接口Fa0/0的1P地址193.1.1.1。PC1査询本地的ARP缓存，如果找到193.1.1.1对应的MAC地址则进行封装；如果在ARP缓存中没有找到193.1.1.1对应的MAC地址，则使用ARP协议，査询到网关对应的MAC地址 &ldquo;00-11-BC-7D-25-03&rdquo; 。于是，这里的源MAC地址是PC1的MAC地址&ldquo;00-1B-24-7D-25-01&rdquo;，目的MAC地址是网关的MAC地址 &ldquo;00-11-BC-7D-25-03&rdquo;

&emsp;&emsp;数据链路层封装后的数据帧下沉到物理层，转换成二进制形式的比特(Bit)流，从PC1的网卡发送出去。物理层的用途就是处理比特流，把比特转换成电子、光学或微波信号。反之在接收端，物理层从传输媒体中重新得到这些信号，恢复成比特流，传输比特流到数据链路层

&emsp;&emsp;注意：协议数据单元在应用层、表示层和会话层被称做数据(Data)，在传输层被称做分段(Segment)，在网络层被称做包(Packet)，在数据链路层被称做帧(Frame)，在物理层被称做比特(Bit)

![transport2](https://pic.xiaohuochai.site/blog/HTTP_transport2.jpg)

&emsp;&emsp;注意：目的MAC地址是路由器接口的MAC地址，而不是目的服务器网卡的MAC地址。因为MAC只是用在局域网内的寻址，如果封装的是目的服务器的MAC地址，如何体现这个包是发往路由器的呢？假设封装的目的MAC地址是服务器的MAC地址 &ldquo;00-1B-24-7D-25-05&rdquo;，这样的数据包被传到路由器后，路由器比较数据帧中的R的MAC地址，发现与本路由器接口的MAC地址不同，路由器丢弃这个包，数据包不被路由器转发，更别想能到达目的服务器了

![transport3](https://pic.xiaohuochai.site/blog/HTTP_transport3.gif)

&nbsp;

### 集线器处理

&emsp;&emsp;PC1发出的比特流到达集线器，集线器简单地对比特流进行放大，从除接收端口以外的所有端口转发出去。PC2接收到这个数据包，把比特流转换成帧上传到数据链路层，PC2比较数据帧的目的MAC地址，发现与本机网卡的MAC地址不同，PC2丢弃该数据帧，放弃处理

&nbsp;

### 路由器1处理

&emsp;&emsp;路由器R1收到该比特流，转换成帧上传到数据链路层，路由器R1比较数据帧的目的MAC地址，发现与路由器接收端口Fa0/0(快速以太网，简写成Fa0/0，指的是0号插槽上编号为0的接口)的MAC地址相同，路由器知道该数据帧是发往本路由器的。路由器R1的数据链路层把数据帧进行解封装，然后上传到路由器R1的网络层，路由器R1看到数据包的目的IP地址是195.1.1.2，并不是发给本路由器的，需要路由器进行转发

&emsp;&emsp;路由器R1査询自己的路由表，发现数据包应该从串行接口S1/1发出。路由器R1把数据包从Fa0/0接口交换到S1/1接口

&emsp;&emsp;此时R1并不能直接把这个数据包发出去，因为在R1的Fa0/0接口被解封装，现在需要被重新再封装。可以想象一个风雪交加的日子，进门的时候拿下帽子，出门的时候需要再戴上帽子。数据封装也是这样，在路由器的入接口解封装，在路由器的出接口需要再封装，和人取下帽子有区别的是，这里解封装去掉的内容和再封装加上去的内容是不一样的。网络层的封装并没有被解开，但并不意味着网络层的信息一点都没有改变，其实网络层的数据包中源和目的IP地址都没有被改变(除非在网络地址转换的情况下)，但TTL(生存周期)会减1。网络层把数据包交给下层的数据链路层，数据链路层需要封装二层的地址。串行链路不同于以太网，因为以太网是一个多路访问的网络，要定位到目的设备需要借助于MAC地址，但串行线路一般的封装协议都是PPP(Point-to-Point Protocol,点到点协议)或HDLC(High-Level Data Link Control,高级数据链路控制协议)封装，这种封装被用于点对点线路，也就是说，一根线缆只连接两台设备，一端发出，另一端肯定可以收到。假设串行线缆上使用的是PPP协议，则数据链路层封装的源和目的地址都是PPP

&emsp;&emsp;数据链路层封装后的数据帧被传到物理层，转换成二进制形式的比特流，从路由器R1的S1/1接口发送出去

![transport4](https://pic.xiaohuochai.site/blog/HTTP_transport4.gif)

&nbsp;

### 路由器2处理

&emsp;&emsp;路由器R2收到这个比特流，上传至数据链路层，数据链路层去掉PPP的封装。路由器R2査询数据包的目的IP地址，发现该IP网络直接连接在Fa0/0接口，路由器R2把数据包交换到Fa0/0接口。路由器查看本地的ARP缓存，如果找到195.1.1.2对应的MAC地址，则直接进行封裝；如果没有找到，则发送ARP的查询包。路由器R2发出数据帧的源地址是Fa0/0接口的MAC地址，目的地址是服务器网卡的MAC地址

&emsp;&emsp;数据链路层封装后的数据帧被传到物理层，转换成二进制形式的比特流，从路由器R2的Fa0/0接口发送出去

![transport5](https://pic.xiaohuochai.site/blog/HTTP_transport5.gif)

&nbsp;

### 交换机处理

&emsp;&emsp;路由器R2发出的比特流到达交换机，交换机除了对比特流进行放大外，还根据源MAC地址进行学习，根据目的MAC地址进行转发。交换机根据数据帧中的目的MAC地址査询MAC地址表，把比特流从对应的端口发送出去，交换机把比特流发往服务器，并没有发往PC3

&nbsp;

### 服务器处理

&emsp;&emsp;服务器接收到这个比特流，把比特流转换成帧格式，上传到数据链路层，服务器发现数据帧中的目的MAC地址与本网卡的MAC地址相同，服务器拆除数据链路层的封装后，把数据包上传到网络层。服务器的网络层比较数据包中的目的IP地址，发现与本机的IP地址相同，服务器拆除网络层的封装后，把数据分段上传到传输层。传输层对数据分段进行确认、排序、重组，确保数据传输的可靠性。数据最后被传到服务器的应用层

&emsp;&emsp;从PC1到Server的整个数据包流动过程，PC1执行OSI七层的封装，然后把比特流传到集线器；集线器在物理层把信号简单放大后，把比特流传到路由器R1；R1执行OSI下三层的处理后，再把比特流传到路由器R2；R2执行OSI下三层的处理后，再把比特流传到交换机；交换机执行OSI下二层的处理后，再把比特流传到服务器

&emsp;&emsp;从这个流动过程中，可以发现数据流在中间设备上主要执行的是OSI下三层的操作，物理层的设备不改变帧的格式，广播式转发：数据链路层的设备也不改变帧的格式，但可以根据数据帧中的目的MAC地址进行转发；网络层的设备改变帧的格式，要执行帧的解封装和再封装，但不改变数据包中的源和目的IP地址

![transport6](https://pic.xiaohuochai.site/blog/HTTP_transport6.jpg)

&nbsp;

### 反向传输

&emsp;&emsp;服务器收到PC1发过来的数据后，对PC1进行响应。和PC1处理的过程类似，服务器也知道要发往一个远程的网络，数据链路层的目的MAC地址需要封装网关的MAC地址；网络层源和目的IP地址与PC1发送过来的包相反，即把源地址变成目的地址，目的地址变成源地址；传输层源和目的端口与PC1发送过来的包相反，即把源端口变成目的端口，目的端口变成源端口

![transport7](https://pic.xiaohuochai.site/blog/HTTP_transport7.gif)
